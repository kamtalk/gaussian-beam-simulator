<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beamseeker 3D</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; }
    #info-pulldown { position: absolute; top: 10px; left: 10px; z-index: 1001; }
    #info-pulldown-trigger { color: rgba(255, 255, 255, 0.6); font-family: sans-serif; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 2px black; padding: 5px 10px; cursor: help; user-select: none; }
    #info-pulldown-content { display: none; margin-top: 5px; padding: 10px; background-color: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px; font-family: sans-serif; font-size: 14px; color: #ccc; }
    #info-pulldown-content p { margin: 0 0 5px 0; }
    #info-pulldown-content a { color: #8af; text-decoration: none; }
    #info-pulldown:hover #info-pulldown-content { display: block; }
    #fullscreen-btn { position: absolute; bottom: 20px; right: 20px; width: 40px; height: 40px; background-color: rgba(0, 0, 0, 0.5); border: 2px solid white; border-radius: 5px; cursor: pointer; z-index: 1000; padding: 6px; box-sizing: border-box; }
    #fullscreen-btn:hover { background-color: rgba(255, 255, 255, 0.2); }
    #fullscreen-btn svg { width: 100%; height: 100%; fill: white; }
    #icon-exit-fs { display: none; }
  </style>
</head>
<body>

<div id="info-pulldown">
  <div id="info-pulldown-trigger">Beamseeker 3D</div>
  <div id="info-pulldown-content">
    <p>Copyright Â© 2024 Kenneth A. Menard</p>
    <p>All Rights Reserved.</p>
    <p><a href="mailto:beamseeker3d@gmail.com">beamseeker3d@gmail.com</a></p>
  </div>
</div>

<button id="fullscreen-btn" title="Toggle Fullscreen">
  <svg id="icon-enter-fs" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zm-3-12V5h-2v5h5V8h-3z"/></svg>
  <svg id="icon-exit-fs" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>
</button>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js",
    "three/examples/jsm/libs/lil-gui.module.min.js": "https://unpkg.com/three@0.161.0/examples/jsm/libs/lil-gui.module.min.js"
  }
}
</script>
<script type="module">
/* @title Beamseeker 3D (Demo) * @description An interactive 3D simulation of Gaussian beam propagation. * @author Kenneth A. Menard * @copyright Copyright (c) 2024 Kenneth A. Menard. All Rights Reserved. * @license Proprietary * @version 1.2.2 */
import * as THREE from 'three';import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';import GUI from 'three/examples/jsm/libs/lil-gui.module.min.js';const __vconfig = "YYZJAX"; const params = {beamLength: 80,beamSegments: 200,waistRadius: 0.001, waistPos: -15,wavelength: 633e-9, visualizationScale: 500,lenses: [ { pos: -5, f: 8 } ],zoom: 25};const BeamEngine = {matMul:(A,B)=>[[A[0][0]*B[0][0]+A[0][1]*B[1][0],A[0][0]*B[0][1]+A[0][1]*B[1][1]],[A[1][0]*B[0][0]+A[1][1]*B[1][0],A[1][0]*B[0][1]+A[1][1]*B[1][1]]],freeSpace:(L)=>[ [1,L],[0,1] ],thinLens:(f)=>(!isFinite(f)||Math.abs(f)<1e-9)?[[1,0],[0,1]]:[[1,0],[-1/f,1]],invertMatrix:(M)=>{const[A,B]=M[0],[C,D]=M[1];return[[D,-B],[-C,A]];},applyABCD:(M,q)=>{const[A,B]=M[0],[C,D]=M[1];const denRe=C*q.re+D,denIm=C*q.im;const denMag2=denRe*denRe+denIm*denIm;if(denMag2===0)return{re:1e9,im:1e9};const numRe=A*q.re+B,numIm=A*q.im;return{re:(numRe*denRe+numIm*denIm)/denMag2,im:(numIm*denRe-numRe*denIm)/denMag2};},w_from_q:(q,lambda)=>{if(q.im<=0)return NaN;const invIm=-q.im/(q.re*q.re+q.im*q.im);const wSqr=-lambda/(Math.PI*invIm);return Math.sqrt(wSqr);},getSystemMatrix:function(start_z,end_z,allLenses){const relevantLenses=allLenses.filter(lens=>lens.pos>start_z&&lens.pos<=end_z).sort((a,b)=>a.pos-b.pos);let M=[[1,0],[0,1]],current_z=start_z;for(const lens of relevantLenses){M=this.matMul(this.freeSpace(lens.pos-current_z),M);M=this.matMul(this.thinLens(lens.f),M);current_z=lens.pos;}M=this.matMul(this.freeSpace(end_z-current_z),M);return M;},getBeamRadiusAt:function(z,config){const{waistPos,waistRadius,wavelength,lenses}=config;const zR=Math.PI*waistRadius*waistRadius/wavelength;const q0={re:0,im:zR};let M;if(z>=waistPos){M=this.getSystemMatrix(waistPos,z,lenses);}else{const M_forward=this.getSystemMatrix(z,waistPos,lenses);M=this.invertMatrix(M_forward);}const qz=this.applyABCD(M,q0);return this.w_from_q(qz,wavelength);},get_q_at:function(z,config){const{waistPos,waistRadius,wavelength,lenses}=config;const zR=Math.PI*waistRadius*waistRadius/wavelength;const q0={re:0,im:zR};let M;if(z>=waistPos){M=this.getSystemMatrix(waistPos,z,lenses);}else{const M_forward=this.getSystemMatrix(z,waistPos,lenses);M=this.invertMatrix(M_forward);}return this.applyABCD(M,q0);}};const scene = new THREE.Scene();scene.background = new THREE.Color(0);const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);const renderer = new THREE.WebGLRenderer({ antialias: true });renderer.setSize(window.innerWidth, window.innerHeight);document.body.appendChild(renderer.domElement);const controls = new OrbitControls(camera, renderer.domElement);controls.enableDamping = true;controls.enableZoom = true;scene.add(new THREE.AxesHelper(10));const gridSize = 1000;scene.add(new THREE.GridHelper(gridSize, gridSize / 2, 0x222222, 0x111111));const lensObjects = new THREE.Group();scene.add(lensObjects);let waistMarker = null;function updateCameraPosition() {const direction = new THREE.Vector3();camera.getWorldDirection(direction);const target = controls.target.clone();camera.position.copy(target).addScaledVector(direction, -params.zoom);}function createBeam() {if (scene.getObjectByName("beam")) { scene.remove(scene.getObjectByName("beam")); }const beamConfig = { ...params };const segments = params.beamSegments, radialSegments = 32;const geometry = new THREE.BufferGeometry();const positions = [], indices = [];const startZ = -params.beamLength / 2;const endZ = params.beamLength / 2;try {for (let i = 0; i <= segments; i++) {const t = i / segments;const z = startZ + t * (endZ - startZ);let physical_radius = BeamEngine.getBeamRadiusAt(z, beamConfig);if (isNaN(physical_radius)) { physical_radius = 0.001; }const visual_radius = Math.min(physical_radius * params.visualizationScale, 10);for (let j = 0; j <= radialSegments; j++) {const v = j / radialSegments * 2 * Math.PI;const cx = Math.cos(v), cy = Math.sin(v);positions.push(visual_radius * cx, visual_radius * cy, z);}}} catch (error) { console.error("FAILED TO CREATE BEAM GEOMETRY:", error); return; }for (let i = 0; i < segments; i++) { for (let j = 0; j < radialSegments; j++) { const a = i * (radialSegments + 1) + j, d = i * (radialSegments + 1) + j + 1, b = (i + 1) * (radialSegments + 1) + j, c = (i + 1) * (radialSegments + 1) + j + 1; indices.push(a, b, d); indices.push(b, c, d); } }geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));geometry.setIndex(indices);const material = new THREE.MeshBasicMaterial({ color: 0x00bb00, wireframe: true, transparent: true, opacity: 0.5 });const mesh = new THREE.Mesh(geometry, material);mesh.name = "beam";scene.add(mesh);}function createAllLenses() {while (lensObjects.children.length > 0) { lensObjects.remove(lensObjects.children[0]); }params.lenses.forEach((lensData) => {const lensRadius = 6;const path = new THREE.Path();if (lensData.f > 0) {const e = 0.2, c = 2.5;path.moveTo(lensRadius, e / 2); path.quadraticCurveTo(0, c / 2, -lensRadius, e / 2); path.quadraticCurveTo(0, -c / 2, lensRadius, e / 2);} else {const e = 0.8, c = 0.1;path.moveTo(lensRadius, e / 2); path.quadraticCurveTo(0, c / 2, -lensRadius, e / 2); path.lineTo(-lensRadius, -e / 2); path.quadraticCurveTo(0, -c / 2, lensRadius, -e / 2); path.closePath();}const geometry = new THREE.LatheGeometry(path.getPoints(32), 64);const material = new THREE.MeshBasicMaterial({ color: 0xaaddff, opacity: 0.4, transparent: true, side: THREE.DoubleSide, depthWrite: false });const lensMesh = new THREE.Mesh(geometry, material);const edges = new THREE.EdgesGeometry(geometry, 1);const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1, transparent: true, opacity: 0.5 });const lineSegments = new THREE.LineSegments(edges, lineMaterial);const lensGroup = new THREE.Group();lensGroup.add(lensMesh);lensGroup.add(lineSegments);lensGroup.rotation.x = Math.PI / 2;lensGroup.position.set(0, 0, lensData.pos);lensGroup.userData.lensData = lensData;lensGroup.userData.defaultColor = material.color.getHex();lensObjects.add(lensGroup);});}function createWaistMarker() {if (waistMarker) { scene.remove(waistMarker); }const geometry = new THREE.SphereGeometry(0.3, 16, 8);const material = new THREE.MeshBasicMaterial({ color: 0xdddd00 });waistMarker = new THREE.Mesh(geometry, material);waistMarker.name = "waistMarker";waistMarker.userData.defaultColor = material.color.getHex();scene.add(waistMarker);}const gui = new GUI();const outputs = { finalWaistPos: 'N/A', finalWaistRadius: 'N/A' };let lensFolder = null;let lensPosControllers = [];let outputControllers = {};let waistPosController = null;function updateSystem(recreateBeam = true) {if (recreateBeam) createBeam();createAllLenses();if (waistMarker) { waistMarker.position.z = params.waistPos; } else { createWaistMarker(); }const beamConfig = { ...params };if (params.lenses.length > 0) {const lastLens = [...params.lenses].sort((a, b) => a.pos - b.pos).pop();const q_after = BeamEngine.get_q_at(lastLens.pos, beamConfig);const newWaistDist = -q_after.re;const newWaistPos = lastLens.pos + newWaistDist;const new_q_waist = { re: 0, im: q_after.im };const newWaistRadius = BeamEngine.w_from_q(new_q_waist, params.wavelength);outputs.finalWaistPos = isNaN(newWaistPos) ? 'Error' : newWaistPos.toFixed(3);outputs.finalWaistRadius = isNaN(newWaistRadius) ? 'Error' : (newWaistRadius * 1000).toFixed(3);} else { outputs.finalWaistPos = 'N/A'; outputs.finalWaistRadius = 'N/A'; }Object.values(outputControllers).forEach(c => c.updateDisplay && c.updateDisplay());}function rebuildGUI() {if (lensFolder) { lensFolder.destroy(); }lensPosControllers = [];lensFolder = gui.addFolder('Lenses');params.lenses.forEach((lens, index) => {const f = lensFolder.addFolder(`Lens ${index + 1}`);const posController = f.add(lens, 'pos', -500, 500, 0.1).name("Position (m)").onChange(() => updateSystem(true));f.add(lens, 'f', -500, 500, 0.1).name("Focal (m)").onChange(() => updateSystem(true));lensPosControllers.push(posController);});lensFolder.open();}const actions = {addLens: () => { const lastPos = params.lenses.length > 0 ? params.lenses.sort((a, b) => a.pos - b.pos)[params.lenses.length - 1].pos : params.waistPos; params.lenses.push({ pos: lastPos + 5, f: 10 }); rebuildGUI(); updateSystem(true); },removeLastLens: () => { if (params.lenses.length > 0) { params.lenses.pop(); rebuildGUI(); updateSystem(true); } }};const fullscreenBtn = document.getElementById('fullscreen-btn');const iconEnter = document.getElementById('icon-enter-fs');const iconExit = document.getElementById('icon-exit-fs');fullscreenBtn.addEventListener('click', () => {if (!document.fullscreenElement) {document.documentElement.requestFullscreen();} else {document.exitFullscreen();}});document.addEventListener('fullscreenchange', () => {if (document.fullscreenElement) {iconEnter.style.display = 'none';iconExit.style.display = 'block';} else {iconEnter.style.display = 'block';iconExit.style.display = 'none';}});const zoomController = gui.add(params, 'zoom', 5, 500, 1).name('Camera Zoom').onChange(updateCameraPosition);gui.add(params, 'beamLength', 20, 200, 5).name("Beam Render Length (m)").onChange(() => updateSystem(true));gui.add(params, 'waistRadius', 0.0005, 0.01, 0.0001).name("Waist Radius (m)").onChange(() => updateSystem(true)).disable();waistPosController = gui.add(params, 'waistPos', -40, 40, 0.1).name("Waist Position (m)").onChange(() => updateSystem(true)).disable();gui.add(params, 'visualizationScale', 100, 1000, 5).name('Visual Thickness').onChange(() => updateSystem(true));gui.add(actions, 'addLens').name('Add Lens');gui.add(actions, 'removeLastLens').name('Remove Last Lens');const outputFolder = gui.addFolder('Calculated Outputs');outputControllers.wz = outputFolder.add(outputs, 'finalWaistPos').name("Final Waist z (m)").listen();outputControllers.wr = outputFolder.add(outputs, 'finalWaistRadius').name("Final Waist r (mm)").listen();scene.add(new THREE.AmbientLight(0xffffff, 1));const dirLight = new THREE.DirectionalLight(0xffffff, 1);dirLight.position.set(-10, 10, 5);scene.add(dirLight);function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }rebuildGUI();updateCameraPosition();updateSystem(true);animate();window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); updateSystem(true); });controls.addEventListener('change', () => {const distance = camera.position.distanceTo(controls.target);if (Math.abs(params.zoom - distance) > 0.1) {params.zoom = distance;zoomController.updateDisplay();}});const raycaster = new THREE.Raycaster();const mouse = new THREE.Vector2();let draggedObject = null;let hoveredObject = null;const dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1));function onMouseMove(event) {mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;raycaster.setFromCamera(mouse, camera);if (draggedObject) {const intersectionPoint = new THREE.Vector3();raycaster.ray.intersectPlane(dragPlane, intersectionPoint);const newZ = intersectionPoint.z;draggedObject.position.z = newZ;if (draggedObject.userData.lensData) {draggedObject.userData.lensData.pos = newZ;lensPosControllers.forEach(c => c.updateDisplay());}} else {const draggableItems = [...lensObjects.children];const intersects = raycaster.intersectObjects(draggableItems, true);const newHovered = intersects.length > 0 ? intersects[0].object.parent : null;if (newHovered !== hoveredObject) {if (hoveredObject) {const obj = hoveredObject.children[0];obj.material.color.setHex(hoveredObject.userData.defaultColor);}if (newHovered) {const obj = newHovered.children[0];obj.material.color.setHex(0xffff00);}hoveredObject = newHovered;}}}function onMouseDown(event) {mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;raycaster.setFromCamera(mouse, camera);const draggableItems = [...lensObjects.children];const intersects = raycaster.intersectObjects(draggableItems, true);if (intersects.length > 0) {controls.enabled = false;draggedObject = intersects[0].object.parent;const obj = draggedObject.children[0];obj.material.color.setHex(0xff0000);dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal).negate(), draggedObject.position);}}function onMouseUp(event) {if (draggedObject) {const obj = draggedObject.children[0];obj.material.color.setHex(hoveredObject === draggedObject ? 0xffff00 : draggedObject.userData.defaultColor);updateSystem(true);}controls.enabled = true;draggedObject = null;}renderer.domElement.addEventListener('mousedown', onMouseDown);renderer.domElement.addEventListener('mousemove', onMouseMove);renderer.domElement.addEventListener('mouseup', onMouseUp);function onTouchStart(event) {event.preventDefault(); onMouseDown(event.touches[0]);}function onTouchMove(event) {event.preventDefault();onMouseMove(event.touches[0]);}function onTouchEnd(event) {onMouseUp(event);}renderer.domElement.addEventListener('touchstart', onTouchStart);renderer.domElement.addEventListener('touchmove', onTouchMove);renderer.domElement.addEventListener('touchend', onTouchEnd);
</script>
</body>
</html>